\documentclass[a4paper, 10pt, french]{article}
\usepackage{mathtools}
% Préambule; packages qui peuvent être utiles
   \RequirePackage[T1]{fontenc}        % Ce package pourrit les pdf...
   \RequirePackage{babel,indentfirst}  % Pour les césures correctes,
                                       % et pour indenter au début de chaque paragraphe
   \RequirePackage[utf8]{inputenc}   % Pour pouvoir utiliser directement les accents
                                     % et autres caractères français
   \RequirePackage{lmodern,tgpagella} % Police de caractères
   \textwidth 17cm \textheight 25cm \oddsidemargin -0.24cm % Définition taille de la page
   \evensidemargin -1.24cm \topskip 0cm \headheight -1.5cm % Définition des marges
   \RequirePackage{latexsym}                  % Symboles
   \RequirePackage{amsmath}                   % Symboles mathématiques
   \RequirePackage{tikz}   % Pour faire des schémas
   \RequirePackage{graphicx} % Pour inclure des images
   \RequirePackage{listings} % pour mettre des listings

   \newcommand{\set}[1]{\left\{ #1 \right\}}
   \newcommand{\abs}[1]{\left| #1 \right|}
   \newcommand{\cplx}[1]{\mathcal O \left( #1 \right)}
% Fin Préambule; package qui peuvent être utiles
\usepackage{moreverb}
\title{Rapport de TP 4MMAOD : Génération de patch optimal}
\author{
Matthieu Bergeron (ISI2A\_G2)
Tom Cornebize (ISI2A\_G2)
}

\setlength\parindent{0pt}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Principe de notre  programme}

\subsection{Équation de Bellman}

Nous rappelons l'équation de Bellman sur laquelle est basé notre programme.

Soient $\ell_1$ (resp. $\ell_2$) le nombre de lignes du fichier $F_1$ (resp. $F_2$).

Nous noterons $F_i[n]$, avec $n \in [1, \ell_i]$, pour dénoter la $n$-ème ligne du fichier
$F_i$. Nous noterons $\abs{F_i[n]}$ la longueur de cette ligne.

Pour $n_1 \in [1, \ell_1]$ et $n_2 \in [1, \ell_2]$, nous définissons $cout(n_1, n_2)$
comme étant le coût du patch de coût minimal permettant de transformer les $n_1$
premières lignes du fichier $F_1$ en les $n_2$ premières lignes du fichier $F_2$.

La fonction $cout$ peut s'écrire de manière inductive :

\[
    cout(n_1, n_2) = \min
    \begin{cases}
        cout(n_1-1, n_2-1)                          & \text{si } F_1[n_1] = F_2[n_2]\\
        cout(n_1-1, n_2-1) + 10 + \abs{F_2[n_2]}    & \text{(substitution)}\\
        cout(n_1-1, n_2) + 10                       & \text{(destruction)}\\
        \min_{i \in [2, n_1]} cout(n_1-i, n_2) + 15          & \text{(destruction multiple)}\\
        cout(n_1, n_2-1) + 10 + \abs{F_2[n_2]}      & \text{(ajout)}
    \end{cases}
\]

Avec comme condition initiale $cout(0, 0) = 0$, $cout(1, 0) = 10$, $cout(n_1, 0) = 15$
si $n_1 > 1$ et $cout(0, n_2)$ = $10n_2$.

\subsection{Implémentation}

Notre programme est une implémentation itérative de cette équation. Il est constitué
de deux boucles \emph{for} imbriquées. La boucle extérieure itère sur l'indice $n_2$
du fichier de sortie et la boucle intérieure itère sur l'indice $n_1$ du fichier
d'entrée.
Voici le pseudo-code de cet algorithme :
\begin{verbatimtab}
	Retourner la réponse directement si on est dans un cas trivial
	Faire les initialisations nécessaires
	for(j=1..n_2)
	  for(i=1..n_1)
		Calcul du patch minimum (i,j) -- Avec l'équation de Bellman

	Retourner le dernier résultat du tableau
\end{verbatimtab}
Notons que le calcul de $cout(n_1, n_2)$ dépend de $cout(n_1-1, n_2)$,
$cout(n_1, n_2-1)$, $cout(n_1-1, n_2-1)$ et $cout(n_1-i, n_2)$ pour tout $i$.
Nous n'avons donc pas besoin de garder en mémoire les valeurs de $cout(i, j)$ pour
$j < n_2-1$.

Nous manipulons deux tableaux de $n_1+1$ cases. Le premier représente les solutions
de $cout(i, n_2)$ pour tout $i$ et pour le $n_2$ courant, le second représente
les solutions de $cout(i, n_2-1)$ pour tout $i$ et pour le $n_2$ courant.
Ainsi, nous évitions de devoir utiliser une matrice de $(n_1+1)\times(n_2+2)$ cases
et faisons donc une économie de mémoire importante.

Pour la destruction multiple, nous devons calculer le patch de coût minimal parmi
tous les patchs précédemment calculés pour une même valeur de $n_2$.
Plutôt que de reparcourir le tableau à chaque fois, nous stockons l'indice de
ce minimum, que nous mettons à jour à chaque nouveau patch calculé.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Analyse du coût théorique}

  \subsection{Nombre  d'opérations en pire cas\,:}
    En reprenant les notations de la partie précédente : \\ \\

    \[T(n_1,n_2,c_1,c_2) = \underbrace{Coût(\text{Cas triviaux})}_{\cplx{n_2}} +
    \underbrace{Coût(\text{Initialisations})}_{\cplx{n_1+n_2}} +
    \sum_{j=1}^{n_2} \sum_{i=1}^{n_1} Coût((\text{Calcul patch (i,j)})\]

	On néglige donc les deux premiers coûts, ce qui nous donne :
	\[T(n_1,n_2,c_1,c_2) = n_1 \times n_2 \times Coût(\text{Calcul patch (i,j)})\]

	Nous devons donc calculer le coût du calcul du patch (i,j), c'est le coût de la fonction \emph{compute\_at\_indexes(index\_in,index\_out)}.

	Décomposons les coûts internes à cette fonction dans le pire cas :
	\begin{itemize}
	\item Une comparaison de chaîne de caractère a un coût de $\cplx{\max(l_i,l_j)}$ en notant $l_i$ (resp. $l_j$) la longueur de la ligne de $i$ (resp $j$).
	\item Un cout constant pour le reste des opérations
	\end{itemize}

	On en déduit que le cout au pire cas de cette fonction vaut : $\cplx{\max(l_i,l_j)}$ (les autres coûts étant constants).

	\[T(n_1,n_2,c_1,c_2) = \sum_{j=1}^{n_2} \sum_{i=1}^{n_1} \max(l_i,l_j) \leq n_1 \times n_2 \times L\]

	Finalement, $T(n_1,n_2,c_1,c_2) = \cplx{(n_1 \times n_2 \times L)}$ avec $L$ la longueur de la plus grande chaîne.

    Notons qu'en pratique, le coût de comparaison de deux chaînes est souvent constant. En effet, on compare d'abord leurs tailles, si celles-ci diffèrent, on déduit
    que les deux chaînes sont différentes.

  \subsection{Place mémoire requise\,: }
	Nous utilisons deux listes pour stocker les informations nécessaire au calcul du coût courant : une pour la ligne courante, l'autre pour la ligne
    précédente. Le patch de cout minimum sur une ligne est stocké avec son indice.
    Le cout total en mémoire doit donc prendre en compte :
    \begin{itemize}
    \item Le coût du stockage des fichiers en entrée : \ $O(c_1 + c_2)$
    \item Le coût des mémorisations :  $\underbrace{n_1}_{ligne\ courante} + \underbrace{n_1}_{ligne\ précédente} + \underbrace{1}_{indice \ minimum} = O(n_1)$
    \end{itemize}

    Ce qui donne un coût de $\cplx{c_1 + c_2 + n_1}$

  \subsection{Nombre de défauts de cache sur le modèle CO\,: }
    Pour simplifier les choses, nous pouvons considérer que nos valeurs sont stockées dans un grand tableau, de taille $2 \times n_1 + 1$.\\
    A l'itération i, le programme a besoin de quatre cases en mémoire :
    \begin{itemize}
    \item $(i-1)$ pour la destruction
    \item $(i - i_{min})$ pour la multi-destruction, $i_{min}$ étant défini tel que $T[i-i_{min}]$ est le patch de cout minimal.
    \item $(i - n_1)$ pour l'addition
    \item $(i - n_1 - 1)$ pour la substitution et l'identité
    \end{itemize}

    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
    	\hline

    	 $i - n_1 - 1$ & $i - n_1$  &  .. & .. & $i - i_{min}$ & .. & .. & $i - 1$ & $i$ \\

    	\hline
    \end{tabular}

	Le nombre de défauts de cache dépend donc de la taille totale Z du cache :

	\textbf{Si $Z > n_1$ :}
    \begin{itemize}
		 \item Un défaut de cache inévitable pour écrire les tranches du tableau dans le cache : $\Theta(\dfrac{n_1}{L})$
		 \item Pas de défaut de cache pour accéder aux cases mémoires : $\Theta(\dfrac{n_1}{L})$
     \end{itemize}

	\textbf{Si $Z < n_1$ :}
    \begin{itemize}
	    \item Défaut inévitable : $\Theta(\dfrac{n_1}{L})$
	    \item Défaut à chaque calcul pour retrouver les patchs dans les cases $(i - n_1)$ et  $(i - n_1 - 1)$ : $\Theta(n_1)$
    \end{itemize}

 	$\Rightarrow \Theta(n_1 (1 + \dfrac{1}{L}) )$
 	Pour simplifier les calculs, nous avons considéré que l'indice $i_{min}$ est soit proche de $i - n_1$, soit proche de $i$.

 	Avec cette simplification, nous sommes sûr d'avoir le patch de cout minimum sur la ligne dans le cache. En effet si la case du patch dans
 	le tableau est proche
 	de la case courante,  elle est déjà dans le cache. Sinon, elle est récupérée avec le cache-miss provoqué par l'accès à l'indice
 	$i - n_1$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compte rendu d'expérimentation}
  \subsection{Conditions expérimentales}
    Notre programme est malheureusement trop lent pour fonctionner sur les benchmark fournis.
    Nous avons pourtant un algorithme qui a une complexité temporelle quadratique
    en la taille des données et une complexité spatiale linéaire en la taille des données,
    ce qui nous semble optimal.

    Nous suspectons que cette lenteur est due à l'utilisation de Python.

    Nous présentons tout de même des résultats expérimentaux dans cette partie,
    qui ont été réalisés sur des fichiers de tailles réduites.

    \subsubsection{Description synthétique de la machine\,:}
      Les tests ont été réalisés sur une machine dotée de 16GB de mémoire vive et
      d'un processeur \emph{I7 5600U} : cache de 4MB, deux coeurs physiques avec
      chacun deux coeurs logiques (technologie Hyper-Threading d'Intel), fréquence
      de 2.6 GHz à 3.2 GHz.
      Le système d'exploitation était \emph{Linux Mint Debian Edition 2}, version 64 bits.
      D'autres processus étaient en cours d'exécution mais ne nécessitaient pas
      d'important coûts de calculs.

    \subsubsection{Méthode utilisée pour les mesures de temps\,: }
      Les mesures de temps ont été effectuées via la commande \emph{time} de Linux.
      Les temps relevés correspondent au temps \emph{real} renvoyé par cette commande,
      afin de prendre en compte le temps passé en mode noyau ou bloqué sur une
      entrée-sortie.
      L'unité de temps est la seconde.
      Les tests ont étés réalisés avec le script \emph{chronometer.sh} accompagnant
      notre programme. À chaque fois, ce script génère un fichier aléatoirement et
      du nombre de lignes souhaités. Puis, il génère un second fichier en copiant
      le premier et en y apportant des modifications, telles que des substitutions,
      additions ou destructions. Ensuite, le script génère un patch en utilisant
      notre programme. Seul le temps de calcul du patch est mesuré ici.
      Pour chaque test, un nouveau fichier est généré : il n'y a donc pas d'effet
      de cache.

  \subsection{Mesures expérimentales}
    Comme mentionné précédemment, les tests n'ont malheureusement pas pu être réalisés
    sur les fichiers fournis.
    Nous présentons ici les résultats de nos expériences, menées sur des fichiers
    générés automatiquement.

    Les coûts des patchs calculés n'étant pas pertinent ici (les fichiers étant
    générés aléatoirement), ils ne seront pas présentés.

    Tous les temps présentés sont exprimés en secondes. Les tailles de fichiers
    sont exprimées en nombre de lignes. Nous rappelons que cette taille est exacte
    pour le fichier d'entrée, mais est une approximation pour le fichier de sortie
    (sa taille pouvant différer du fichier d'entrée à cause d'additions ou destructions).
    En pratique, cette différence reste raisonnable.

    \begin{figure}[h]
      \begin{center}
        \begin{tabular}{|l||r|r|r||}
          \hline
          \hline
            taille des &   temps     & temps   & temps \\
            fichiers &   min       & max     & moyen \\
          \hline
          \hline
            200 &  0.22      &   0.24  &  0.23   \\
          \hline
            500 &  1.01      &   1.04  &  1.023   \\
          \hline
            1000 &   4.41     &  4.78   &  4.59   \\
          \hline
            2000 & 20.11   &  21.00   &  21.08   \\
          \hline
            4000 & 88.82  &    92.26   &  90.84  \\
          \hline
          \hline
        \end{tabular}
        \caption{Mesures des temps minimum, maximum et moyen de 5 exécutions pour différentes tailles de fichiers.}
        \label{table-temps}
      \end{center}
    \end{figure}

\subsection{Analyse des résultats expérimentaux}
On remarque que lorsque la taille des fichiers double, le temps d'exécution est
multiplié par légèrement plus de quatre. Nous avions calculés un coût quadratique
pour notre algorithme, ces résultats sont donc cohérents avec notre analyse.

\section{Question\,: et  si le coût d'un patch était sa taille en octets ?}

Dans ce cas, les coûts des opérations sont redéfinis: \\ \\
Nous noterons $F_i[n]$, avec $n \in [1, \ell_i]$, pour dénoter la $n$-ème ligne du fichier
$F_i$. Nous noterons $\abs{F_i[n]}$ la longueur de cette ligne. \\
On note N le nombre de lignes à détruire pour la destruction multiple. \\
On suppose aussi que la taille d'un caractère est d'un octet. \\ \\
\begin{tabular}{|c|c|c|c|c|}
    	\hline
    	 Ajout & Substitution & Destruction Simple & Destruction Multiple \\
    	 \hline
    	 $4 + \lceil{}log_{10} n_1\rceil{} + \abs{F_2[n_2]}$ & $4 + \lceil{}log_{10} n_1\rceil{} + \abs{F_2[n_2]}$ &  $4 + \lceil{}log_{10} n_1\rceil{}$&  $5 +  \lceil{}log_{10} n_1\rceil{} + \lceil{}log_{10} N\rceil{}$    \\
    	\hline
    \end{tabular}
    \\ \\
    On arrive finalement à l'équation de bellman suivante :
\[
    cout(n_1, n_2) = \min
    \begin{cases}
        cout(n_1-1, n_2-1)                          & \text{si } F_1[n_1] = F_2[n_2]\\
        cout(n_1-1, n_2-1) + 4 + \lceil{}log_{10} n_1\rceil{} + \abs{F_2[n_2]}   & \text{(substitution)}\\
        cout(n_1-1, n_2) + 4 + \lceil{}log_{10} n_1\rceil{}                       & \text{(destruction)}\\
        \min_{i \in [2, n_1]} cout(n_1-i, n_2) + 5 +  \lceil{}log_{10} n_1\rceil{} + \lceil{}log_{10} N\rceil{}       \\  \ \ \text{avec} \  \ N = n2 - \text{arg}\min_{i \in [2, n_1]}cout(n_1-i, n_2) & \text{(destruction multiple)}\\
        cout(n_1, n_2-1) + 4 + \lceil{}log_{10} n_1\rceil{} + \abs{F_2[n_2]}      & \text{(ajout)}
    \end{cases}
\]

Notons qu'il serait astucieux de ne pas utiliser la fonction logarithme dans notre l'implémentation, mais
plutot utiliser un algorithme qui permettant de calculer la "taille" d'un nombre en décimal.
\end{document}
